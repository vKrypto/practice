package problem22

import (
	"reflect"
	"testing"
)

type testType struct {
	in   int
	want []string
}

func TestGenerateParenthesis(t *testing.T) {
	tests := [...]testType{
		{
			in: 3,
			want: []string{
				"((()))",
				"(()())",
				"(())()",
				"()(())",
				"()()()",
			},
		},
		{
			in: 2,
			want: []string{
				"(())",
				"()()",
			},
		},
		{
			in:   1,
			want: []string{"()"},
		},
		{
			in:   0,
			want: []string{},
		},
		{
			in: 5,
			want: []string{
				"((((()))))",
				"(((()())))",
				"(((())()))",
				"(((()))())",
				"(((())))()",
				"((()(())))",
				"((()()()))",
				"((()())())",
				"((()()))()",
				"((())(()))",
				"((())()())",
				"((())())()",
				"((()))(())",
				"((()))()()",
				"(()((())))",
				"(()(()()))",
				"(()(())())",
				"(()(()))()",
				"(()()(()))",
				"(()()()())",
				"(()()())()",
				"(()())(())",
				"(()())()()",
				"(())((()))",
				"(())(()())",
				"(())(())()",
				"(())()(())",
				"(())()()()",
				"()(((())))",
				"()((()()))",
				"()((())())",
				"()((()))()",
				"()(()(()))",
				"()(()()())",
				"()(()())()",
				"()(())(())",
				"()(())()()",
				"()()((()))",
				"()()(()())",
				"()()(())()",
				"()()()(())",
				"()()()()()",
			},
		},
	}
	for _, tt := range tests {
		got := generateParenthesis(tt.in)
		if !reflect.DeepEqual(got, tt.want) {
			t.Fatalf("in: %v, got: %v, want: %v", tt.in, got, tt.want)
		}
	}
}
