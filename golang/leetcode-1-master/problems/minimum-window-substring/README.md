<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    openset <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/openset                                 |-->
<!--|@home      https://github.com/openset/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](../sort-colors "Sort Colors")
　　　　　　　　　　　　　　　　
[Next >](../combinations "Combinations")

## [76. Minimum Window Substring (Hard)](https://leetcode.com/problems/minimum-window-substring "最小覆盖子串")

<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>

<p><strong>Example:</strong></p>

<pre>
<strong>Input: S</strong> = &quot;ADOBECODEBANC&quot;, <strong>T</strong> = &quot;ABC&quot;
<strong>Output:</strong> &quot;BANC&quot;
</pre>

<p><strong>Note:</strong></p>

<ul>
	<li>If there is no such window in S that covers all characters in T, return the empty string <code>&quot;&quot;</code>.</li>
	<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li>
</ul>

### Related Topics
  [[Hash Table](../../tag/hash-table/README.md)]
  [[Two Pointers](../../tag/two-pointers/README.md)]
  [[String](../../tag/string/README.md)]
  [[Sliding Window](../../tag/sliding-window/README.md)]

### Similar Questions
  1. [Substring with Concatenation of All Words](../substring-with-concatenation-of-all-words) (Hard)
  1. [Minimum Size Subarray Sum](../minimum-size-subarray-sum) (Medium)
  1. [Sliding Window Maximum](../sliding-window-maximum) (Hard)
  1. [Permutation in String](../permutation-in-string) (Medium)
  1. [Minimum Window Subsequence](../minimum-window-subsequence) (Hard)

### Hints
<details>
<summary>Hint 1</summary>
Use two pointers to create a window of letters in <b>S</b>, which would have all the characters from <b>T</b>.
</details>

<details>
<summary>Hint 2</summary>
Since you have to find the minimum window in <b>S</b> which has all the characters from <b>T</b>, you need to expand and contract the window using the two pointers and keep checking the window for all the characters. This approach is also called Sliding Window Approach.

<br><br>
<pre>
L ------------------------ R , Suppose this is the window that contains all characters of <b>T</b> 
                          
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp L----------------- R , this is the contracted window. We found a smaller window that still contains all the characters in <b>T</b>

When the window is no longer valid, start expanding again using the right pointer. </pre>
</details>
